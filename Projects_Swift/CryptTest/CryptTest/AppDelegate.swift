//
//  AppDelegate.swift
//  CryptTest
//
//  Created by RUSLAN on 08.06.2021.
//

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        
//        if launchOptions?[UIApplication.LaunchOptionsKey.remoteNotification] != nil {


       // Do what you want to happen when a remote notification is tapped.

            
            
        
        NotificationCenter.default.addObserver(forName:UIApplication.willEnterForegroundNotification, object: nil, queue: nil) { (_) in
              // Your Code here
            print("Зашел в приложение")
      }

        
        NotificationCenter.default.addObserver(forName:UIApplication.didEnterBackgroundNotification, object: nil, queue: nil) { (_) in
               //  Дейсвтие при заходе в бекграунд режим
            print("Вышел из приложения")
        }

//       }
        
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        
//        print("USER TURNED OFF")
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        print("Приложение завершено")
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    
    
    
    
    
    func applicationDidEnterBackground(_ application: UIApplication) {
            /*
             You need to create a backgroundTaksToken (short hand for bgtToken). It is token/identifier to indicate the
             task that will be performed in the background.
             It has only one value - .invalid
             And, we always want to start with .invalid
             */
            var bgtToken = UIBackgroundTaskIdentifier.invalid
            
            /*
             We call UIApplication.share.beginBackgroundTask funcion to inform the system that
             there is task we wish to perform.
             And, here, the UIApplication will change `.invalid` value of bgtToken to some valid token.
             the bgtToken is entirely system generated. So all you have to know is that the bgtToken now should be valid.
             */
            bgtToken = UIApplication.shared.beginBackgroundTask(expirationHandler: {
                print("Backround Task")
                /*
                 The expirationHandler is a closure that allows you do clean up
                 if your task has somehow exceeded even the prolonged `background state` period.
                 Here, what we usually do is that we will end the task if it exceeds the time so that our app
                 can gracefully move on to the `suspend state` without being termninated by the system.
                 We do that by calling `.endBackgroundTask(bgtToken)`
                 
                 
                 Note: `expirationHandler` is actually called not when the background time has exceeded already.
                 Rather, it is called when the background time IS ABOUT TO EXCEED.
                 So strictly, you still have some time to perform other tasks, like cleaning up other parts of code.
                 But it is stronglt discouraged. Because when `expirationHandler` is called, the time remaining is
                 background is already minimal. So you should simply call only `UIApplication.shared.endBackgroundTask(bgtToken)`
                 to end the current task and do other kind of cleaning up some where else before this time has arrived.
                 */
                UIApplication.shared.endBackgroundTask(bgtToken)
            })
            
            
            /*
             A safety check to see if the bgtToken generated by UIApplication is valid or not.
             If it remains `.invalid`, we do not want to move on and perform the task because we do not
             have any identifier that points to the task to manipulate it in the way we would want.
             */
            guard bgtToken != .invalid else{
                return
            }
            
            /*
             Since it is a lengthy task, always put it in background thread.
             If you put it in main thread thinking that the app is already minimised so hogging on
             main thread does not hurt will cause your app to be terminated by the system.
             */
            DispatchQueue.global(qos: .utility).async {
                /*
                 Here, you call your lengthy background task
                 */
//                self.someBackgroundTask()
                print("Backround Task")
                DispatchQueue.main.async {
                    /*
                     When the backgroundTask is done, you inform UIApplication to end the task
                     so that your app now is safe to move on to `suspend state`.
                     Do not assume that when your backgroundTask() is completed, your app will be
                     automatically informed of the complete notification.
                     You need to explicitly inform your application through the `backgroundTaskToken` that
                     was generated.
                     */
                    print("Backround Task")
                    
                    UIApplication.shared.endBackgroundTask(bgtToken)
                }
            }
        }

}

